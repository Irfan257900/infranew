name: Deploy TST Environment

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    defaults:
      run:
        working-directory: ./environments/tst

    steps:
      - name: Check out the repository code
        uses: actions/checkout@v3

      #
      # --- THIS STEP IS THE FIX ---
      #
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          # This line installs the Az PowerShell module (which has Invoke-AzVMRunCommand)
          enable-AzPSSession: true 

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Clear local Terraform cache and Lock File
        run: |
          echo "Removing .terraform directory..."
          rm -rf .terraform
          echo "Removing .terraform.lock.hcl file..."
          rm -f .terraform.lock.hcl
      
      # The "Unlock and Clean State File" step has been removed

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        timeout-minutes: 30
        env:
          TF_VAR_vm_admin_password: ${{ secrets.VM_ADMIN_PASSWORD }}
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        timeout-minutes: 90
        run: terraform apply -auto-approve tfplan

      #
      # --- THIS STEP WILL NOW SUCCEED ---
      #
      - name: Configure SQL Server (PowerShell Method)
        if: success()
        env:
          SQL_ADMIN_PASS: ${{ secrets.VM_ADMIN_PASSWORD }}
          SQL_APP_PASS: ${{ secrets.APP_SQL_PASSWORD }}
          SQL_ADMIN_USER: "Volticatstadmin"
          RG_NAME: "rg-Voltica-tst-vm"
          VM_NAME: "Volticatstsql"
        
        shell: pwsh 

        run: |
          echo "Starting SQL Server configuration..."
          
          # This is the PowerShell script we will run on the VM
          $scriptBlock = @"
          Write-Host '========================================='
          Write-Host 'Starting SQL Server Database Configuration'
          Write-Host '========================================='
          Write-Host 'Admin User: $($env:SQL_ADMIN_USER)'
          Write-Host ''

          try {
              Write-Host 'Step 1: Importing SqlServer module...'
              Import-Module SqlServer -ErrorAction Stop
              Write-Host '✓ SqlServer module loaded successfully'
              Write-Host ''
              
              Write-Host 'Step 2: Creating database VolticaDB...'
              \$createDbQuery = "
                IF NOT EXISTS (SELECT name FROM sys.databases WHERE name = N'VolticaDB')
                BEGIN
                    CREATE DATABASE VolticaDB;
                    SELECT 'Database VolticaDB created successfully' AS Result;
                END
                ELSE
                BEGIN
                    SELECT 'Database VolticaDB already exists' AS Result;
                END
              "
              \$dbResult = Invoke-Sqlcmd -Query \$createDbQuery -ServerInstance 'localhost' -Username "$($env:SQL_ADMIN_USER)" -Password "$($env:SQL_ADMIN_PASS)"
              Write-Host \$dbResult.Result
              Write-Host ''
              
              Write-Host 'Step 3: Creating login voltica_app_user...'
              \$createLoginQuery = "
                IF NOT EXISTS (SELECT name FROM sys.server_principals WHERE name = N'voltica_app_user')
                BEGIN
                    CREATE LOGIN voltica_app_user WITH PASSWORD = '$($env:SQL_APP_PASS)';
                    SELECT 'Login voltica_app_user created successfully' AS Result;
                END
                ELSE
                BEGIN
                    SELECT 'Login voltica_app_user already exists' AS Result;
                END
              "
              \$loginResult = Invoke-Sqlcmd -Query \$createLoginQuery -ServerInstance 'localhost' -Username "$($env:SQL_ADMIN_USER)" -Password "$($env:SQL_ADMIN_PASS)"
              Write-Host \$loginResult.Result
              Write-Host ''
              
              Write-Host 'Step 4: Creating database user and assigning permissions...'
              \$createUserQuery = "
                USE VolticaDB;
                IF NOT EXISTS (SELECT name FROM sys.database_principals WHERE name = N'voltica_app_user')
                BEGIN
                    CREATE USER voltica_app_user FOR LOGIN voltica_app_user;
                    ALTER ROLE db_owner ADD MEMBER voltica_app_user;
                    SELECT 'User voltica_app_user created and added to db_owner role' AS Result;
                END
                ELSE
                BEGIN
                    SELECT 'User voltica_app_user already exists' AS Result;
                END
              "
              \$userResult = Invoke-Sqlcmd -Query \$createUserQuery -ServerInstance 'localhost' -Username "$($env:SQL_ADMIN_USER)" -Password "$($env:SQL_ADMIN_PASS)"
              Write-Host \$userResult.Result
              Write-Host ''
              
              Write-Host '========================================='
              Write-Host '✅ SQL configuration completed successfully!'
              Write-Host '========================================='
          }
          catch {
              Write-Host ''
              Write-Host '========================================='
              Write-Host '❌ SQL CONFIGURATION FAILED'
              Write-Host '========================================='
              Write-Host "Error Message: `n\$($_.Exception.Message)"
              Write-Host "Stack Trace: `n\$($_.ScriptStackTrace)"
              Write-Host '========================================='
              exit 1
          }
          "@
          
          # 3. Send the script to the VM using the PowerShell-native command
          echo "Sending configuration script to VM: $env:VM_NAME in RG: $env:RG_NAME"
          Invoke-AzVMRunCommand `
            -ResourceGroupName $env:RG_NAME `
            -VMName $env:VM_NAME `
            -CommandId 'RunPowerShellScript' `
            -ScriptString $scriptBlock

      #
      # --- THIS IS YOUR DYNAMIC ZAPIER TRIGGER STEP ---
      #
      - name: Trigger Post-Deployment Automation
        if: success()  # Only run if deployment and DB script succeed
        env:
          ZAPIER_WEBHOOK_URL: ${{ secrets.ZAPIER_WEBHOOK_URL }}
          RG_NAME: "rg-Voltica-tst-vm"
          VM_NAME: "Volticatstsql"
        shell: bash
        run: |
          echo "Gathering dynamic data for Zapier..."
          
          # Get Project Name and User from GitHub
          PROJECT_NAME="${{ github.event.repository.name }}"
          TRIGGERING_USER="${{ github.actor }}"
          
          # Get the VM's Network Interface (NIC) ID
          NIC_ID=$(az vm show -g $RG_NAME -n $VM_NAME --query "networkProfile.networkInterfaces[0].id" -o tsv)
          
          # Get the Public IP ID from the NIC
          PIP_ID=$(az network nic show --ids $NIC_ID --query "ipConfigurations[0].publicIpAddress.id" -o tsv)
          
          # Get the actual IP address from the Public IP resource
          VM_PUBLIC_IP=$(az network public-ip show --ids $PIP_ID --query "ipAddress" -o tsv)
          
          # Get the VM's Fully Qualified Domain Name (if it has one, otherwise it's blank)
          VM_FQDN=$(az network public-ip show --ids $PIP_ID --query "dnsSettings.fqdn" -o tsv)

          # Use the FQDN if it exists, otherwise use the IP
          if [ -z "$VM_FQDN" ]; then
            VM_URL="http://$VM_PUBLIC_IP"
          else
            VM_URL="http://$VM_FQDN"
          fi

          echo "Dynamic Data Found: IP=$VM_PUBLIC_IP, URL=$VM_URL"

          # Create the JSON payload
          JSON_PAYLOAD=$(cat <<EOF
          {
            "projectName": "$PROJECT_NAME",
            "triggeringUser": "$TRIGGERING_USER",
            "vmUrl": "$VM_URL", 
            "vmIp": "$VM_PUBLIC_IP",
            "ownerEmail": "irfanmd2579@gmail.com"
          }
          EOF
          )
          
          # Send the webhook
          echo "Sending payload to Zapier:"
          echo $JSON_PAYLOAD
          
          curl -X POST "$ZAPIER_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD"
