name: Deploy TST Environment

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    defaults:
      run:
        working-directory: ./environments/tst

    steps:
      # ===========================
      # 1Ô∏è‚É£ Checkout Repository Code
      # ===========================
      - name: Check out the repository code
        uses: actions/checkout@v3

      # ===========================
      # 2Ô∏è‚É£ Log in to Azure
      # ===========================
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true 

      # ===========================
      # 3Ô∏è‚É£ Setup Terraform
      # ===========================
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Clear Terraform Cache and Lock
        run: |
          rm -rf .terraform
          rm -f .terraform.lock.hcl

      # ===========================
      # 4Ô∏è‚É£ Terraform Init + Plan + Apply
      # ===========================
      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        timeout-minutes: 30
        env:
          TF_VAR_vm_admin_password: ${{ secrets.VM_ADMIN_PASSWORD }}
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        timeout-minutes: 90
        run: terraform apply -auto-approve tfplan

      # ===========================
      # 5Ô∏è‚É£ Configure SQL Database inside the VM
      # ===========================
      - name: Configure SQL Server Database
        if: success()
        env:
          SQL_ADMIN_USER: "Volticatstadmin"                # VM SQL admin username
          SQL_ADMIN_PASS: ${{ secrets.VM_ADMIN_PASSWORD }} # Admin password
          SQL_APP_PASS: ${{ secrets.APP_SQL_PASSWORD }}    # App DB user password
          RG_NAME: "rg-Voltica-tst-vm"                     # Your Resource Group
          VM_NAME: "Volticatstsql"                         # Your SQL VM name
        shell: pwsh
        run: |
          echo "Starting SQL Database configuration inside VM..."

          # Ensure Az.Compute is available for Invoke-AzVMRunCommand
          Install-Module -Name Az.Compute -Force -AllowClobber -Scope CurrentUser

          # Define the PowerShell script to run inside the VM
          $scriptBlock = @"
          Write-Host '========================================='
          Write-Host 'üöÄ Starting SQL Server Database Setup'
          Write-Host '========================================='
          try {
              Write-Host 'Installing SqlServer module...'
              Install-Module -Name SqlServer -Force -AllowClobber -Scope CurrentUser
              Import-Module SqlServer

              Write-Host 'Step 1: Create database VolticaDB...'
              \$createDbQuery = "
                IF NOT EXISTS (SELECT name FROM sys.databases WHERE name = N'VolticaDB')
                BEGIN
                    CREATE DATABASE VolticaDB;
                    SELECT 'Database VolticaDB created successfully' AS Result;
                END
                ELSE
                BEGIN
                    SELECT 'Database VolticaDB already exists' AS Result;
                END
              "
              \$dbResult = Invoke-Sqlcmd -ServerInstance 'localhost' -Username '$($env:SQL_ADMIN_USER)' -Password '$($env:SQL_ADMIN_PASS)' -Query \$createDbQuery
              Write-Host \$dbResult.Result

              Write-Host 'Step 2: Create login voltica_app_user...'
              \$createLoginQuery = "
                IF NOT EXISTS (SELECT name FROM sys.server_principals WHERE name = N'voltica_app_user')
                BEGIN
                    CREATE LOGIN voltica_app_user WITH PASSWORD = '$($env:SQL_APP_PASS)';
                    SELECT 'Login voltica_app_user created successfully' AS Result;
                END
                ELSE
                BEGIN
                    SELECT 'Login voltica_app_user already exists' AS Result;
                END
              "
              \$loginResult = Invoke-Sqlcmd -ServerInstance 'localhost' -Username '$($env:SQL_ADMIN_USER)' -Password '$($env:SQL_ADMIN_PASS)' -Query \$createLoginQuery
              Write-Host \$loginResult.Result

              Write-Host 'Step 3: Create DB user and assign permissions...'
              \$createUserQuery = "
                USE VolticaDB;
                IF NOT EXISTS (SELECT name FROM sys.database_principals WHERE name = N'voltica_app_user')
                BEGIN
                    CREATE USER voltica_app_user FOR LOGIN voltica_app_user;
                    ALTER ROLE db_owner ADD MEMBER voltica_app_user;
                    SELECT 'User voltica_app_user created and added to db_owner' AS Result;
                END
                ELSE
                BEGIN
                    SELECT 'User voltica_app_user already exists' AS Result;
                END
              "
              \$userResult = Invoke-Sqlcmd -ServerInstance 'localhost' -Username '$($env:SQL_ADMIN_USER)' -Password '$($env:SQL_ADMIN_PASS)' -Query \$createUserQuery
              Write-Host \$userResult.Result

              Write-Host 'Step 4: Seed sample data into VolticaDB...'
              \$seedDataQuery = "
                USE VolticaDB;
                IF OBJECT_ID('dbo.AppLogs', 'U') IS NULL
                BEGIN
                    CREATE TABLE dbo.AppLogs (
                        LogId INT IDENTITY(1,1) PRIMARY KEY,
                        Message NVARCHAR(255),
                        CreatedAt DATETIME DEFAULT GETDATE()
                    );
                    INSERT INTO dbo.AppLogs (Message) VALUES ('Database initialized'), ('Seed data inserted successfully');
                    SELECT '‚úÖ Table AppLogs created and data seeded' AS Result;
                END
                ELSE
                BEGIN
                    INSERT INTO dbo.AppLogs (Message) VALUES ('Database reconfigured successfully');
                    SELECT '‚ÑπÔ∏è Table AppLogs already exists, inserted new log entry' AS Result;
                END
              "
              \$seedResult = Invoke-Sqlcmd -ServerInstance 'localhost' -Username '$($env:SQL_ADMIN_USER)' -Password '$($env:SQL_ADMIN_PASS)' -Query \$seedDataQuery
              Write-Host \$seedResult.Result

              Write-Host '========================================='
              Write-Host '‚úÖ SQL Database configuration completed successfully!'
              Write-Host '========================================='
          }
          catch {
              Write-Host '‚ùå Error: ' \$_.Exception.Message
              exit 1
          }
          "@

          # Execute inside the SQL VM
          Invoke-AzVMRunCommand `
            -ResourceGroupName $env:RG_NAME `
            -VMName $env:VM_NAME `
            -CommandId 'RunPowerShellScript' `
            -ScriptString $scriptBlock

      # ===========================
      # 6Ô∏è‚É£ Trigger Zapier Webhook (post-deploy)
      # ===========================
      - name: Trigger Post-Deployment Automation
        if: success()
        env:
          ZAPIER_WEBHOOK_URL: ${{ secrets.ZAPIER_WEBHOOK_URL }}
          RG_NAME: "rg-Voltica-tst-vm"
          VM_NAME: "Volticatstsql"
        shell: bash
        run: |
          echo "Waiting 30 seconds for Azure to stabilize..."
          sleep 30

          echo "Collecting VM public IP..."
          NIC_ID=$(az vm show -g $RG_NAME -n $VM_NAME --query "networkProfile.networkInterfaces[0].id" -o tsv)
          PIP_ID=$(az network nic show --ids $NIC_ID --query "ipConfigurations[0].publicIpAddress.id" -o tsv)
          VM_PUBLIC_IP=$(az network public-ip show --ids $PIP_ID --query "ipAddress" -o tsv)
          VM_URL="http://$VM_PUBLIC_IP"

          JSON_PAYLOAD=$(cat <<EOF
          {
            "projectName": "${{ github.event.repository.name }}",
            "appServiceUrl": "$VM_URL",
            "appServiceIp": "$VM_PUBLIC_IP",
            "ownerEmail": "irfanmd2579@gmail.com"
          }
          EOF
          )

          echo "Sending webhook to Zapier..."
          curl -X POST "$ZAPIER_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD"
